import { ApolloServer } from 'apollo-server-express';
//import { buildFederatedSchema } from '@apollo/federation';
// import { typeDefsAdmin } from '../typeDefs';
// import { resolvers as resolversAdmin } from './resolvers';
import responseCachePlugin from 'apollo-server-plugin-response-cache';
import { GraphQLRequestContext } from 'apollo-server-types';
import { sentryPlugin } from '@pocket-tools/apollo-utils';
import { ApolloServerPluginLandingPageGraphQLPlayground } from 'apollo-server-core';
import { client } from '../database/client';
import { buildSchemaSync } from 'type-graphql';
import { resolvers } from '@generated/type-graphql';

// Export the DB client separately to be able to use it integration tests, too
// Note that we name it 'prisma' rather than 'db' as resolvers generated by
// TypeGraphQL expect to see 'prisma' here.
export const prisma = client();

// Build an admin schema with ALL the resolvers TypeGraphQL generates
// based on our prisma.schema file
const schema = buildSchemaSync({ resolvers, validate: false });

export const server = new ApolloServer({
  // schema: buildFederatedSchema([
  //   { typeDefs: typeDefsAdmin, resolvers: resolversAdmin },
  // ]),
  // TODO: do we need to use buildFederatedSchema on the admin server? Discuss
  schema,
  plugins: [
    //Copied from Apollo docs, the sessionID signifies if we should seperate out caches by user.
    responseCachePlugin({
      //https://www.apollographql.com/docs/apollo-server/performance/caching/#saving-full-responses-to-a-cache
      //The user id is added to the request header by the apollo gateway (client api)
      sessionId: (requestContext: GraphQLRequestContext) =>
        requestContext?.request?.http?.headers?.has('userId')
          ? requestContext?.request?.http?.headers?.get('userId')
          : null,
    }),
    sentryPlugin,
    ApolloServerPluginLandingPageGraphQLPlayground(),
  ],
  context: {
    prisma,
  },
});
