import {
  ApprovedItem,
  CuratedStatus,
  Prisma,
  PrismaClient,
} from '@prisma/client';
import faker from 'faker';
// the minimum of data required to create a approved curated item
interface CreateApprovedItemHelperRequiredInput {
  title: string;
}

// optional information you can provide when creating an approved curated item
interface CreateApprovedItemHelperOptionalInput {
  prospectId?: string;
  url?: string;
  excerpt?: string;
  status?: CuratedStatus;
  language?: string;
  publisher?: string;
  imageUrl?: string;
  createdBy?: string;
  topic?: string;
  isCollection?: boolean;
  isShortLived?: boolean;
  isSyndicated?: boolean;
}

// the input type the helper function expects - a combo of required and optional parameters
export type CreateApprovedItemHelperInput =
  CreateApprovedItemHelperRequiredInput & CreateApprovedItemHelperOptionalInput;

/**
 * A helper function that creates a sample approved curated item for testing or local development.
 * @param prisma
 * @param data
 */
export async function createApprovedItemHelper(
  prisma: PrismaClient,
  data: CreateApprovedItemHelperInput
): Promise<ApprovedItem> {
  const random = Math.round(Math.random() * 1000);

  // defaults for optional properties
  const createApprovedItemDefaults = {
    prospectId: faker.datatype.uuid(),
    // A URL that contains just a domain name is not enough as domain names
    // tend to get repeats even with ~100 items generated by the seed script,
    // so the URL needs a little more to stay reliably unique.
    url: `${faker.internet.url()}/${faker.lorem.slug()}/${faker.datatype.uuid()}`,
    excerpt: faker.lorem.sentence(15),
    status: faker.random.arrayElement([
      CuratedStatus.RECOMMENDATION,
      CuratedStatus.CORPUS,
    ]),
    language: faker.random.arrayElement(['en', 'de']),
    publisher: faker.company.companyName(),
    imageUrl: faker.random.arrayElement([
      `${faker.image.nature()}?random=${random}`,
      `${faker.image.city()}?random=${random}`,
      `${faker.image.food()}?random=${random}`,
    ]),
    // Plain strings for now, but we may be able to consume some sort of enum
    // from a "source of truth" API further down the track.
    topic: faker.random.arrayElement([
      'BUSINESS',
      'CAREER',
      'EDUCATION',
      'ENTERTAINMENT',
      'FOOD',
      'GAMING',
      'HEALTH & FITNESS',
      'PARENTING',
      'PERSONAL FINANCE',
      'POLITICS',
      'SCIENCE',
      'SELF IMPROVEMENT',
      'SPORTS',
      'TECHNOLOGY',
      'TRAVEL',
    ]),
    isCollection: faker.datatype.boolean(),
    isShortLived: faker.datatype.boolean(),
    isSyndicated: faker.datatype.boolean(),
    createdAt: faker.date.recent(14),
    createdBy: faker.fake('{{hacker.noun}}|{{internet.email}}'), // imitation auth0 user id
    // occasionally, this may create an item that was updated before it was created. It's ok though,
    // we're only setting this so that orderBy in queries can be tested.
    updatedAt: faker.date.recent(7),
  };

  const inputs: Prisma.ApprovedItemCreateInput = {
    ...createApprovedItemDefaults,
    ...data,
  };

  return await prisma.approvedItem.create({ data: inputs });
}
